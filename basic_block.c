#include "basic_block.h"
#include "instr.h"

#ifdef BASIC_BLOCK_TRACE
#include <stdio.h>
#endif

#if GUM_NATIVE_CPU == GUM_CPU_AMD64

static const guint8 afl_maybe_log_code[] = {
    0x9c,                                      /* pushfq */
    0x50,                                      /* push rax */
    0x51,                                      /* push rcx */
    0x52,                                      /* push rdx */
    0x56,                                      /* push rsi */

    0x89, 0xf8,                                /* mov eax, edi */
    0xc1, 0xe0, 0x08,                          /* shl eax, 8 */
    0xc1, 0xef, 0x04,                          /* shr edi, 4 */
    0x31, 0xc7,                                /* xor edi, eax */
    0x0f, 0xb7, 0xc7,                          /* movzx eax, di */
    0x48, 0x8d, 0x0d, 0x47, 0x00, 0x00, 0x00,  /* lea rcx, sym._afl_instr_rms */
    0x8b, 0x09,                                /* mov ecx, dword [rcx] */
    0x48, 0x39, 0xc8,                          /* cmp rax, rcx */
    0x73, 0x29,                                /* jae beach */
    0x48, 0x8d, 0x0d, 0x31, 0x00, 0x00, 0x00,  /* lea rcx, sym._afl_area_ptr_ptr */
    0x48, 0x8b, 0x09,                          /* mov rcx, qword [rcx] */
    0x48, 0x8b, 0x09,                          /* mov rcx, qword [rcx] */
    0x48, 0x8d, 0x15, 0x1c, 0x00, 0x00, 0x00,  /* lea rdx, sym._afl_prev_loc_ptr */
    0x48, 0x8b, 0x32,                          /* mov rsi, qword [rdx] */
    0x48, 0x8b, 0x36,                          /* mov rsi, qword [rsi] */
    0x48, 0x31, 0xc6,                          /* xor rsi, rax */
    0xfe, 0x04, 0x31,                          /* inc byte [rcx + rsi] */
    0x48, 0xd1, 0xe8,                          /* shr rax, 1 */
    0x48, 0x8b, 0x0a,                          /* mov rcx, qword [rdx] */
    0x48, 0x89, 0x01,                          /* mov qword [rcx], rax */

    /* beach: */
    0x5e,                                      /* pop rsi */
    0x5a,                                      /* pop rdx */
    0x59,                                      /* pop rcx */
    0x58,                                      /* pop rax */
    0x9d,                                      /* popfq */

    0xeb, 0x14,                                /* jmp rest */

    /* Read-only data goes here: */
        /* uint64_t* afl_prev_loc_ptr */
        /* uint8_t** afl_area_ptr_ptr */
        /* unsigned int afl_instr_rms */

    /* rest: */
};

/*
 * Generated by Clang from:
 *
 *     #include <stdint.h>
 *     #include <stdlib.h>
 *
 *     #define MAP_SIZE_POW2 16
 *     #define MAP_SIZE (1 << MAP_SIZE_POW2)
 *
 *     uint8_t** afl_area_ptr_ptr;
 *     unsigned int afl_instr_rms;
 *     uint64_t* __afl_prev_loc;
 *
 *     void afl_maybe_log(size_t current_pc) {
 *         size_t offset = (current_pc >> 4) ^ (current_pc << 8);
 *         offset &= MAP_SIZE - 1;
 *         if (offset >= afl_instr_rms) return;
 *
 *         (*afl_area_ptr_ptr)[offset ^ *__afl_prev_loc]++;
 *         *__afl_prev_loc = offset >> 1;
 *     }
 *
 * With five push/pop pairs manually added to the prolog/epilog.
 */

#else

static void on_basic_block(GumCpuContext* context, gpointer user_data) {
    guint64 current_pc = GUM_ADDRESS (user_data);
#ifdef BASIC_BLOCK_TRACE
    printf("Entered BB @ 0x%llx\n", current_pc);
#endif
    afl_maybe_log(current_pc);
}

#endif

void instr_basic_block(GumStalkerIterator* iterator, GumStalkerOutput* output, gpointer user_data) {
    range_t* range = (range_t*) user_data;

    const cs_insn* instr;
    gboolean begin = TRUE;
    while (gum_stalker_iterator_next(iterator, &instr)) {
        if (begin) {
            guint64 current_pc = instr->address - range->base_address;
            if (range->code_start <= current_pc && range->code_end >= current_pc) {
#ifdef BASIC_BLOCK_TRACE
              printf("Transforming BB @ 0x%llx\n", current_pc);
#endif
#if GUM_NATIVE_CPU == GUM_CPU_AMD64
              GumX86Writer* cw = output->writer.x86;

              gum_x86_writer_put_lea_reg_reg_offset(cw, GUM_REG_RSP, GUM_REG_RSP, -GUM_RED_ZONE_SIZE);
              gum_x86_writer_put_push_reg(cw, GUM_REG_RDI);
              gum_x86_writer_put_mov_reg_address(cw, GUM_REG_RDI, GUM_ADDRESS(current_pc));

              gum_x86_writer_put_bytes(cw, afl_maybe_log_code, sizeof(afl_maybe_log_code));

              uint64_t* afl_prev_loc_ptr = &range->afl_prev_loc;
              uint8_t** afl_area_ptr_ptr = &afl_area_ptr;
              gum_x86_writer_put_bytes(cw, (const guint8 *) &afl_prev_loc_ptr, sizeof(afl_prev_loc_ptr));
              gum_x86_writer_put_bytes(cw, (const guint8 *) &afl_area_ptr_ptr, sizeof(afl_area_ptr_ptr));
              gum_x86_writer_put_bytes(cw, (const guint8 *) &afl_instr_rms, sizeof(afl_instr_rms));

              gum_x86_writer_put_pop_reg(cw, GUM_REG_RDI);
              gum_x86_writer_put_lea_reg_reg_offset(cw, GUM_REG_RSP, GUM_REG_RSP, GUM_RED_ZONE_SIZE);
#else
              gum_stalker_iterator_put_callout(iterator, on_basic_block, GSIZE_TO_POINTER (current_pc), NULL);
#endif
              begin = FALSE;
            }
        }

        gum_stalker_iterator_keep(iterator);
    }
}